name: Issue Assistant

on:
  issues:
    types:
      - opened
      - edited
      - reopened
      - labeled

permissions:
  contents: read
  issues: write

jobs:
  ai-review:
    if: github.event.action == 'opened' || github.event.action == 'edited' || github.event.action == 'reopened' || (github.event.action == 'labeled' && (github.event.label.name == 'AI-Rerun' || github.event.label.name == 'ai-rerun'))
    runs-on: ubuntu-latest
    concurrency:
      group: issue-assistant-ai-review-${{ github.repository }}
      cancel-in-progress: false
    steps:
      - name: Create pending AI review comment
        id: pending_comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;
            const resp = await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: [
                '## ğŸ¤– AI å®¡æŸ¥è¿›è¡Œä¸­',
                '',
                'æ­£åœ¨åˆ†æè¯¥ Issue å¹¶ç”Ÿæˆæ€»ç»“ã€æ ‡é¢˜ä¼˜åŒ–ä¸æ ‡ç­¾å»ºè®®ï¼Œè¯·ç¨å€™â€¦'
              ].join('\n')
            });

            core.setOutput('comment_id', String(resp.data.id));

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: 1.2.19

      - name: Start Copilot API proxy in local runner (bun)
        shell: bash
        env:
          COPILOT_GH_TOKEN: ${{ secrets.COPILOT_GH_TOKEN }}
        run: |
          set -euo pipefail

          TOKEN="${COPILOT_GH_TOKEN:-}"

          if [ -z "$TOKEN" ]; then
            echo "Missing repository secret: COPILOT_GH_TOKEN"
            exit 1
          fi

          rm -rf .copilot-api
          git clone --depth 1 https://github.com/ericc-ch/copilot-api.git .copilot-api

          pushd .copilot-api >/dev/null
          bun install --frozen-lockfile

          # æŒ‰é¡¹ç›®è¦æ±‚ä½¿ç”¨åŒ start å‘½ä»¤
          nohup bun run start start --github-token "$TOKEN" --port 4141 --rate-limit 10 --wait \
            > "$GITHUB_WORKSPACE/copilot-api.log" 2>&1 &
          echo $! > "$GITHUB_WORKSPACE/copilot-api.pid"
          popd >/dev/null

          for i in $(seq 1 60); do
            if curl -fsS http://127.0.0.1:4141/v1/models >/dev/null 2>&1; then
              echo "copilot-api is ready"
              break
            fi
            sleep 2
          done

          if ! curl -fsS http://127.0.0.1:4141/v1/models >/dev/null 2>&1; then
            echo "copilot-api failed to become ready in time"
            tail -n 200 "$GITHUB_WORKSPACE/copilot-api.log" || true
            exit 1
          fi

      - name: Analyze issue with GPT-5-mini
        id: analyze
        uses: actions/github-script@v7
        env:
          OPENAI_BASE_URL: http://127.0.0.1:4141/v1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const failAnalysis = (reason) => {
              const message = String(reason || 'unknown-error').slice(0, 1500);
              const fallback = {
                summary: 'AI å®¡æŸ¥å¤±è´¥ï¼Œå·²å›é€€ä¸ºäººå·¥å¤„ç†å»ºè®®ã€‚',
                better_title: String(issue?.title || 'æœªæä¾›æ ‡é¢˜').slice(0, 200),
                type: 'Question',
                negative: 'none',
                priority: 'ğŸŸ¨Medium',
                needs_info: true,
                need_more_info_items: ['è¯·è¡¥å……å¤ç°æ­¥éª¤ã€è¿è¡Œç¯å¢ƒä¸æ—¥å¿—å‹ç¼©åŒ…ã€‚'],
                confidence: 0,
                labels: ['Question', 'ğŸŸ¨Medium', 'Needs-Info']
              };

              core.setOutput('analysis_result', JSON.stringify(fallback));
              core.setOutput('analyze_ok', 'false');
              core.setOutput('analyze_error', message);
              core.warning('AI analyze failed: ' + message);
            };

            try {

            let notFixPolicyDoc = '';
            try {
              const fileResp = await github.rest.repos.getContent({
                owner,
                repo,
                path: 'AI_NOT_FIX_CASES.md'
              });

              if (!Array.isArray(fileResp.data) && fileResp.data.content) {
                notFixPolicyDoc = Buffer.from(fileResp.data.content, 'base64').toString('utf8');
              }
            } catch (e) {
              core.warning('Failed to load AI_NOT_FIX_CASES.md: ' + e.message);
            }

            const openIssuesRaw = await github.paginate(github.rest.issues.listForRepo, {
              owner,
              repo,
              state: 'open',
              per_page: 100
            });

            const openIssues = openIssuesRaw
              .filter(i => !i.pull_request && i.number !== issue.number)
              .slice(0, 80)
              .map(i => {
                const labels = (i.labels || []).map(l => typeof l === 'string' ? l : l.name).filter(Boolean);
                const bodyShort = String(i.body || '').replace(/\s+/g, ' ').slice(0, 180);
                return `#${i.number} | ${i.title} | labels=[${labels.join(', ')}] | body=${bodyShort}`;
              });

            const allowedType = ['BUG', 'Documentation', 'Enhancement', 'Question'];
            const allowedNegative = ['Duplicate', 'WontFix', 'Invalid', 'duplicate', 'wontfix', 'invalid'];
            const allowedPriority = ['ğŸŸªCritical', 'ğŸŸ¥High', 'ğŸŸ¨Medium', 'ğŸŸ©Low'];

            const prompt = [
              'ä½ æ˜¯ä¸€ä¸ª GitHub Issue åˆ†è¯ŠåŠ©æ‰‹ã€‚',
              'è¯·æ ¹æ® issue æ ‡é¢˜å’Œå†…å®¹ï¼Œè¾“å‡ºä¸¥æ ¼ JSONï¼ˆä¸è¦è¾“å‡º markdown ä»£ç å—ï¼‰ã€‚',
              'è¯­è¨€è¦æ±‚ï¼šæ‰€æœ‰è‡ªç„¶è¯­è¨€å­—æ®µå¿…é¡»ä½¿ç”¨ç®€ä½“ä¸­æ–‡ï¼ˆåŒ…æ‹¬ summaryã€better_titleã€need_more_info_itemsï¼‰ã€‚',
              'ç¦æ­¢è¾“å‡ºè‹±æ–‡å¥å­ï¼ˆä¸“æœ‰åè¯ä¸æ ‡ç­¾åé™¤å¤–ï¼‰ã€‚',
              'è¡¨è¾¾è¦æ±‚ï¼šsummary ä¸ better_title å¿…é¡»ä¸ºå®¢è§‚é™ˆè¿°ï¼Œä¸ä½¿ç”¨ç–‘é—®è¯­æ°”ã€‚',
              'need_more_info_items å…è®¸ä½¿ç”¨ç¤¼è²Œæé—®å¼è¡¨è¾¾ï¼ˆå¦‚â€œè¯·é—®â€¦æ˜¯å¦â€¦/èƒ½å¦â€¦â€ï¼‰ã€‚',
              'æ ¸å¿ƒç›®æ ‡ï¼šä¼˜å…ˆâ€œå®Œå–„ç”¨æˆ·æ„å›¾â€ï¼Œè€Œä¸æ˜¯è¦æ±‚æ™®é€šç”¨æˆ·å†™ä¸“ä¸šæ–¹æ¡ˆã€‚',
              'è¯·å°†ç”¨æˆ·åŸå§‹æè¿°æ•´ç†ä¸ºå¯æ‰§è¡Œæ„å›¾ï¼Œè¡¥é½åˆç†ä¸Šä¸‹æ–‡ï¼ˆåœ¨ä¸è‡†é€ äº‹å®å‰æä¸‹ï¼‰ã€‚',
              'åªæœ‰åœ¨â€œå…³é”®ä¿¡æ¯ç¼ºå¤±ä¼šé˜»æ–­å¤„ç†â€æ—¶æ‰è®¾ç½® needs_info=trueã€‚',
              'need_more_info_items å¿…é¡»æ˜¯ç®€çŸ­ã€ä½é—¨æ§›ã€éæŠ€æœ¯åŒ–çš„è¡¥å……å»ºè®®ï¼ˆæœ€å¤š 2 æ¡ï¼‰ã€‚',
              'ä¸è¦è¦æ±‚æ™®é€šç”¨æˆ·æä¾›æ¶æ„è®¾è®¡ã€éšç§ç­–ç•¥ã€æ€§èƒ½è¯„ä¼°ã€å¤æ‚é›†æˆè¯´æ˜ç­‰ä¸“ä¸šææ–™ã€‚',
              'é‡å¤åˆ¤æ–­è§„åˆ™ï¼šåªä¸â€œå½“å‰ Open Issuesâ€æ¯”è¾ƒæ˜¯å¦é‡å¤ï¼Œä¸ä½¿ç”¨ Closed Issues åšé‡å¤åˆ¤å®šã€‚',
              'ç­–ç•¥è§„åˆ™ï¼šå¯å‚è€ƒ not-fix ç­–ç•¥æ ·ä¾‹ï¼ˆAI_NOT_FIX_CASES.mdï¼‰ã€‚è‹¥å‘½ä¸­ç­–ç•¥ä¸” Open ä¸­æ— é‡å¤ï¼Œå¯ç»™ WontFixï¼›è‹¥ Open ä¸­æœ‰åŒç±»ï¼Œç»™ Duplicateã€‚',
              'å¿…é¡»åªä»ä»¥ä¸‹æšä¸¾ä¸­é€‰æ‹©æ ‡ç­¾ï¼š',
              'type: BUG | Documentation | Enhancement | Question',
              'negative: Duplicate | WontFix | Invalid | none',
              'priority: ğŸŸªCritical | ğŸŸ¥High | ğŸŸ¨Medium | ğŸŸ©Low',
              'needs_info: true | false',
              'æ ‡ç­¾é‡Šä¹‰ï¼ˆå¿…é¡»ä¸¥æ ¼æŒ‰æ­¤ç†è§£ï¼‰ï¼š',
              '- AI-Rerun: Reuse AI reviewï¼ˆäººå·¥è§¦å‘é‡æ–°å®¡æŸ¥ï¼‰',
              '- BUG: Something isn\'t working',
              '- Confirm: Agree to AI review operation',
              '- Documentation: Improvements or additions to documentation',
              '- Duplicate: This issue or pull request already exists',
              '- Enhancement: New feature or request',
              '- Invalid: There is no such issue',
              '- Needs-Info: Issue requires more information',
              '- NEW: New Issue',
              '- Question: Question related to the project',
              '- WontFix: This will not be worked on',
              '- ğŸŸ¥High: High priority',
              '- ğŸŸ¨Medium: Medium priority',
              '- ğŸŸ©Low: Low priority',
              '- ğŸŸªCritical: The program has a critical error that prevents it from running',
              'æ­¤å¤–æä¾› summary(ä¸è¶…è¿‡120å­—)ã€better_title(ç®€æ´æ˜ç¡®)ã€need_more_info_items(æ•°ç»„ï¼Œæœ€å¤š2æ¡)ã€confidence(0-1)ã€‚',
              'å¦‚æœä¿¡æ¯æ˜æ˜¾ä¸è¶³ï¼Œneeds_info å¿…é¡»ä¸º trueã€‚',
              'è‹¥ negative ä¸æ˜¯ noneï¼Œä»éœ€ç»™å‡º type ä¸ priorityã€‚',
              'æ ‡é¢˜è§„åˆ™ï¼šbetter_title å¿…é¡»æ ¹æ® type è‡ªåŠ¨åŠ å‰ç¼€ï¼šBUG=>[BUG]ï¼ŒEnhancement=>[Feature]ï¼ŒQuestion=>[Question]ï¼ŒDocumentation=>[Doc]ã€‚',
              '',
              'Issue æ ‡é¢˜ï¼š',
              issue.title,
              '',
              'Issue æ­£æ–‡ï¼š',
              body,
              '',
              'å½“å‰ Open Issuesï¼ˆç”¨äºé‡å¤åˆ¤æ–­ï¼Œä»…æ­¤åˆ—è¡¨å‚ä¸é‡å¤åˆ¤å®šï¼‰ï¼š',
              openIssues.length ? openIssues.join('\n') : 'ï¼ˆæ— ï¼‰',
              '',
              'Not-Fix ç­–ç•¥æ ·ä¾‹æ–‡æ¡£ï¼ˆç”¨äºç­–ç•¥å‚è€ƒï¼Œä¸ç›´æ¥ä½œä¸ºé‡å¤ç›®æ ‡ï¼‰ï¼š',
              notFixPolicyDoc || 'ï¼ˆæœªæ‰¾åˆ° AI_NOT_FIX_CASES.mdï¼‰'
            ].join('\n');

            const baseUrl = process.env.OPENAI_BASE_URL || 'http://127.0.0.1:4141/v1';
            const preferredModel = process.env.OPENAI_MODEL || 'gpt-5-mini';

            const headers = {
              'Content-Type': 'application/json'
            };

            if (process.env.OPENAI_API_KEY) {
              headers['Authorization'] = 'Bearer ' + process.env.OPENAI_API_KEY;
            }

            const pickModel = async () => {
              try {
                const modelsResp = await fetch(baseUrl + '/models', { headers, method: 'GET' });
                if (!modelsResp.ok) return preferredModel;
                const modelsData = await modelsResp.json();
                const ids = Array.isArray(modelsData?.data)
                  ? modelsData.data.map(m => String(m?.id || '')).filter(Boolean)
                  : [];

                if (ids.includes(preferredModel)) return preferredModel;

                const candidates = ['gpt-5-mini', 'gpt-4.1', 'gpt-4o', 'o4-mini', 'o3-mini'];
                for (const c of candidates) {
                  if (ids.includes(c)) return c;
                }

                return ids[0] || preferredModel;
              } catch {
                return preferredModel;
              }
            };

            const model = await pickModel();
            core.info(`Issue assistant selected model: ${model}`);

            const extractRawContent = (data) => {
              const choice = data?.choices?.[0] || {};
              const msg = choice?.message || {};

              if (typeof msg.content === 'string') return msg.content;

              if (Array.isArray(msg.content)) {
                return msg.content
                  .map(part => {
                    if (typeof part === 'string') return part;
                    if (typeof part?.text === 'string') return part.text;
                    if (typeof part?.content === 'string') return part.content;
                    return '';
                  })
                  .join('\n')
                  .trim();
              }

              if (typeof choice?.text === 'string') return choice.text;
              return '';
            };

            const parseJsonObject = (raw) => {
              const trimmed = String(raw || '').trim();
              if (!trimmed) throw new Error('empty-content');

              try {
                return JSON.parse(trimmed);
              } catch {
                const cleaned = trimmed
                  .replace(/^```json\s*/i, '')
                  .replace(/^```\s*/i, '')
                  .replace(/```$/i, '')
                  .trim();

                try {
                  return JSON.parse(cleaned);
                } catch {
                  const first = cleaned.indexOf('{');
                  const last = cleaned.lastIndexOf('}');
                  if (first >= 0 && last > first) {
                    const candidate = cleaned.slice(first, last + 1);
                    return JSON.parse(candidate);
                  }
                  throw new Error('invalid-json-content');
                }
              }
            };

            const doCompletion = async (useJsonResponseFormat) => {
              const payload = {
                model,
                temperature: 0.1,
                messages: [
                  { role: 'system', content: 'ä½ æ˜¯ä¸¥è°¨çš„ issue å®¡æŸ¥åŠ©æ‰‹ï¼Œåªè¾“å‡º JSONï¼Œä¸”æ‰€æœ‰è‡ªç„¶è¯­è¨€å­—æ®µå¿…é¡»ä¸ºç®€ä½“ä¸­æ–‡ï¼›summary ä¸ better_title å¿…é¡»å®¢è§‚é™ˆè¿°ï¼Œä¸ä½¿ç”¨æé—®è¯­æ°”ã€‚need_more_info_items å…è®¸ç¤¼è²Œæé—®ã€‚' },
                  { role: 'user', content: prompt }
                ]
              };

              if (useJsonResponseFormat) {
                payload.response_format = { type: 'json_object' };
              }

              const resp = await fetch(baseUrl + '/chat/completions', {
                method: 'POST',
                headers,
                body: JSON.stringify(payload)
              });

              const respText = await resp.text();

              return { resp, respText };
            };

            let parsed;
            let lastError = null;
            const attemptLogs = [];

            for (const useJsonResponseFormat of [true, false]) {
              try {
                const attemptName = `${useJsonResponseFormat ? 'json' : 'plain'}`;
                const { resp, respText } = await doCompletion(useJsonResponseFormat);
                if (!resp.ok) {
                  throw new Error(`completion-${resp.status}: ${respText}`);
                }

                let data;
                try {
                  data = JSON.parse(respText);
                } catch {
                  throw new Error('completion-non-json: ' + String(respText || '').slice(0, 1200));
                }

                const raw = extractRawContent(data);
                const usage = data?.usage || {};
                const finishReason = data?.choices?.[0]?.finish_reason || 'unknown';
                attemptLogs.push(`${attemptName} usage=${JSON.stringify(usage)} finish=${finishReason} rawLen=${raw.length}`);
                core.info(`AI attempt ${attemptName} rawLen=${raw.length} finish=${finishReason}`);

                parsed = parseJsonObject(raw);
                break;
              } catch (e) {
                lastError = e;
                attemptLogs.push(`${useJsonResponseFormat ? 'json' : 'plain'} error=${String(e?.message || e).slice(0, 300)}`);
              }
            }

            if (!parsed) {
              failAnalysis('AI completion failed or returned invalid JSON: ' + (lastError?.message || 'unknown-error') + ' | attempts=' + attemptLogs.join(' ; '));
              return;
            }

            const result = {
              summary: String(parsed.summary || '').slice(0, 300),
              better_title: String(parsed.better_title || issue.title).slice(0, 200),
              type: allowedType.includes(parsed.type) ? parsed.type : 'Question',
              negative: (parsed.negative === 'none' || !parsed.negative)
                ? 'none'
                : (allowedNegative.includes(parsed.negative)
                  ? ({
                      duplicate: 'Duplicate',
                      wontfix: 'WontFix',
                      invalid: 'Invalid'
                    }[String(parsed.negative).toLowerCase()] || parsed.negative)
                  : 'none'),
              priority: allowedPriority.includes(parsed.priority) ? parsed.priority : 'ğŸŸ¨Medium',
              needs_info: Boolean(parsed.needs_info),
              need_more_info_items: Array.isArray(parsed.need_more_info_items)
                ? parsed.need_more_info_items.slice(0, 5).map(v => String(v).slice(0, 200))
                : [],
              confidence: Math.max(0, Math.min(1, Number(parsed.confidence ?? 0.6)))
            };

            result.need_more_info_items = result.need_more_info_items
              .map(v => String(v || '').trim())
              .filter(Boolean)
              .slice(0, 2);

            // å¯¹æ™®é€šç”¨æˆ·å‹å¥½ï¼šé«˜ç½®ä¿¡åº¦æ—¶é»˜è®¤ä¸ç´¢è¦è¡¥å……ï¼›åªæœ‰å…³é”®é˜»æ–­æ—¶æ‰ needs_info=true
            if (result.confidence >= 0.75) {
              result.needs_info = false;
              result.need_more_info_items = [];
            }

            if (result.needs_info && result.need_more_info_items.length === 0) {
              result.need_more_info_items = ['å¯è¡¥å……ä¸€ä¸ªå…·ä½“åœºæ™¯æˆ–å¤ç°æ­¥éª¤ï¼ˆç®€çŸ­å³å¯ï¼‰ï¼Œä¾¿äºæ›´å¿«å¤„ç†ã€‚'];
            }

            const titlePrefixByType = {
              BUG: '[BUG]',
              Enhancement: '[Feature]',
              Question: '[Question]',
              Documentation: '[Doc]'
            };
            const normalizedTitleCore = String(result.better_title || issue.title || '')
              .replace(/^\s*\[[^\]]+\]\s*/g, '')
              .trim();
            const safeTitleCore = normalizedTitleCore || 'æœªæä¾›æ ‡é¢˜';
            const prefix = titlePrefixByType[result.type] || '[Question]';
            result.better_title = `${prefix} ${safeTitleCore}`.slice(0, 200);

            if (!result.summary || !result.summary.trim()) {
              result.summary = 'å·²å®Œæˆè‡ªåŠ¨åˆ†è¯Šï¼Œè¯·æŸ¥çœ‹å»ºè®®æ ‡ç­¾ä¸è¡¥å……é¡¹ã€‚';
            }

            result.summary = result.summary.replace(/[?ï¼Ÿ]+/g, 'ã€‚').trim();

            const labels = [result.type, result.priority];
            if (result.negative !== 'none') labels.push(result.negative);
            if (result.needs_info) labels.push('Needs-Info');

            result.labels = labels;

            if (!Array.isArray(result.labels) || result.labels.length < 2) {
              failAnalysis('normalized-result-missing-labels');
              return;
            }

            core.setOutput('analysis_result', JSON.stringify(result));
            core.setOutput('analyze_ok', 'true');
            core.setOutput('analyze_error', '');
            } catch (e) {
              failAnalysis(e?.message || e);
            }

      - name: Stop Copilot API proxy
        if: always()
        shell: bash
        run: |
          set +e

          if [ -f "$GITHUB_WORKSPACE/copilot-api.pid" ]; then
            PID="$(cat "$GITHUB_WORKSPACE/copilot-api.pid")"
            if [ -n "$PID" ] && kill -0 "$PID" >/dev/null 2>&1; then
              kill "$PID" >/dev/null 2>&1 || true
              sleep 1
              kill -9 "$PID" >/dev/null 2>&1 || true
            fi
          fi

          pkill -f "bun run start start" >/dev/null 2>&1 || true

          echo "----- copilot-api log (tail 200) -----"
          tail -n 200 "$GITHUB_WORKSPACE/copilot-api.log" || true
          echo "copilot-api process cleaned"

      - name: Publish AI review comment
        if: always() && steps.analyze.outputs.analyze_ok == 'true'
        uses: actions/github-script@v7
        env:
          AI_RESULT: ${{ steps.analyze.outputs.analysis_result }}
          AI_COMMENT_ID: ${{ steps.pending_comment.outputs.comment_id }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;
            const commentId = Number(process.env.AI_COMMENT_ID || 0);
            const raw = String(process.env.AI_RESULT || '').trim();

            if (!raw) {
              const body = [
                '## âš ï¸ AI å®¡æŸ¥ç»“æœä¸ºç©º',
                '',
                'æœ¬æ¬¡å®¡æŸ¥æ‰§è¡Œå®Œæˆï¼Œä½†æœªæ”¶åˆ°å¯ç”¨çš„ç»“æ„åŒ–ç»“æœï¼ˆAI_RESULT ä¸ºç©ºï¼‰ã€‚',
                'è¯·æ·»åŠ  `AI-Rerun` é‡è¯•ï¼›å¦‚æŒç»­å¤ç°ï¼Œè¯·æ£€æŸ¥ä»£ç†è¿”å›æ ¼å¼ã€‚'
              ].join('\n');

              if (commentId > 0) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: commentId,
                  body
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body
                });
              }
              return;
            }

            let result;
            try {
              result = JSON.parse(raw);
            } catch (e) {
              const body = [
                '## âš ï¸ AI å®¡æŸ¥ç»“æœä¸å¯è§£æ',
                '',
                'æœ¬æ¬¡å®¡æŸ¥è¿”å›äº†é JSON ç»“æœï¼Œæ— æ³•ç”Ÿæˆå»ºè®®ã€‚',
                `- è§£æé”™è¯¯ï¼š\`${String(e?.message || e).replace(/`/g, '\\`')}\``,
                'è¯·æ·»åŠ  `AI-Rerun` é‡è¯•ã€‚'
              ].join('\n');

              if (commentId > 0) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: commentId,
                  body
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body
                });
              }
              return;
            }

            if (!Array.isArray(result.labels) || result.labels.length < 2) {
              const body = [
                '## âš ï¸ AI å®¡æŸ¥ç»“æœä¸å®Œæ•´',
                '',
                'æœ¬æ¬¡å®¡æŸ¥è¿”å›å­—æ®µç¼ºå¤±ï¼ˆlabels ä¸å®Œæ•´ï¼‰ï¼Œå·²é˜»æ­¢å‘å¸ƒæ— æ•ˆå»ºè®®ã€‚',
                'è¯·æ·»åŠ  `AI-Rerun` é‡è¯•ã€‚'
              ].join('\n');

              if (commentId > 0) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: commentId,
                  body
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body
                });
              }
              return;
            }

            const marker = '<!-- ai-issue-review:' + JSON.stringify(result).replace(/-->/g, '--ï¼') + ' -->';
            const lines = [];
            lines.push('## ğŸ¤– AI å®¡æŸ¥ç»“æœ');
            lines.push('');
            lines.push('- **æ€»ç»“**: ' + (result.summary || 'ï¼ˆæ— ï¼‰'));
            lines.push('- **å»ºè®®æ ‡é¢˜**: ' + (result.better_title || issue.title));
            lines.push('- **å»ºè®®æ ‡ç­¾**: ' + (Array.isArray(result.labels) && result.labels.length ? result.labels.map(v => '`' + v + '`').join(' ') : 'ï¼ˆæ— ï¼‰'));
            lines.push('- **æ˜¯å¦éœ€è¦è¡¥å……ä¿¡æ¯**: ' + (result.needs_info ? 'æ˜¯' : 'å¦'));
            lines.push('- **ç½®ä¿¡åº¦**: ' + Math.round((Number(result.confidence || 0) * 100)) + '%');

            if (Array.isArray(result.need_more_info_items) && result.need_more_info_items.length > 0) {
              lines.push('');
              lines.push(result.needs_info ? '### å»ºè®®è¡¥å……ï¼ˆå°½é‡ç®€çŸ­ï¼‰' : '### å¯é€‰è¡¥å……ï¼ˆå¦‚æ–¹ä¾¿ï¼‰');
              for (const item of result.need_more_info_items) {
                lines.push('- ' + item);
              }
            }

            lines.push('');
            lines.push('ç»´æŠ¤è€…å¦‚åŒæ„æœ¬æ¬¡ AI ç»“æœï¼Œè¯·æ·»åŠ æ ‡ç­¾ `Confirm`ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨æ‰§è¡Œæ ‡ç­¾è½åœ°å¹¶ç§»é™¤ `Confirm`ã€‚');
            lines.push('å¦‚éœ€å†æ¬¡è§¦å‘ AI é‡å®¡ï¼Œå¯æ·»åŠ æ ‡ç­¾ `AI-Rerun`ã€‚');
            lines.push(marker);

            if (commentId > 0) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: commentId,
                body: lines.join('\n')
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: lines.join('\n')
              });
            }

      - name: Fallback comment when AI review fails
        if: always() && steps.analyze.outputs.analyze_ok != 'true'
        uses: actions/github-script@v7
        env:
          ANALYZE_ERROR: ${{ steps.analyze.outputs.analyze_error }}
          AI_COMMENT_ID: ${{ steps.pending_comment.outputs.comment_id }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;
            const reason = String(process.env.ANALYZE_ERROR || 'unknown-error').slice(0, 1000);
            const commentId = Number(process.env.AI_COMMENT_ID || 0);
            const body = [
              '## âš ï¸ AI å®¡æŸ¥æš‚æ—¶å¤±è´¥',
              '',
              'æœ¬æ¬¡è‡ªåŠ¨å®¡æŸ¥æœªæˆåŠŸå®Œæˆï¼ˆå¯èƒ½æ˜¯æœåŠ¡å¯åŠ¨å¤±è´¥ã€ç½‘ç»œæ³¢åŠ¨ã€é™æµæˆ–ä¸Šæ¸¸å“åº”å¼‚å¸¸ï¼‰ã€‚',
              `- è¯Šæ–­ä¿¡æ¯ï¼š\`${reason.replace(/`/g, '\\`')}\``,
              'ä½ å¯ä»¥ç¨åç¼–è¾‘è¯¥ Issue æˆ–é‡æ–°æ‰“å¼€ Issue ä»¥è§¦å‘å†æ¬¡å®¡æŸ¥ã€‚',
              '',
              'ç»´æŠ¤è€…ä¹Ÿå¯ç›´æ¥æ‰‹åŠ¨æ‰“æ ‡ç­¾å¤„ç†ï¼Œä¸å½±å“æ­£å¸¸æµç¨‹ã€‚'
            ].join('\\n');

            if (commentId > 0) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: commentId,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body
              });
            }

      - name: Remove ai-rerun label after processing
        if: always() && github.event.action == 'labeled' && (github.event.label.name == 'AI-Rerun' || github.event.label.name == 'ai-rerun')
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            for (const name of ['AI-Rerun', 'ai-rerun']) {
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.issue.number,
                  name
                });
              } catch {
                // ignore absent label
              }
            }

  confirm-apply:
    if: github.event.action == 'labeled' && (github.event.label.name == 'Confirm' || github.event.label.name == 'confirm')
    runs-on: ubuntu-latest
    steps:
      - name: Apply AI review result after confirm
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = issue.number;

            const typeGroup = ['BUG', 'Documentation', 'Enhancement', 'Question', 'bug', 'documentation', 'enhancement', 'question'];
            const negativeGroup = ['Duplicate', 'WontFix', 'Invalid', 'duplicate', 'wontfix', 'invalid'];
            const priorityGroup = ['ğŸŸªCritical', 'ğŸŸ¥High', 'ğŸŸ¨Medium', 'ğŸŸ©Low'];

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number,
              per_page: 100
            });

            const markerRegex = /<!--\s*ai-issue-review:(.*?)-->/s;
            let aiPayload = null;

            for (let i = comments.length - 1; i >= 0; i--) {
              const c = comments[i];
              if (!c.body) continue;
              const m = c.body.match(markerRegex);
              if (!m) continue;
              try {
                aiPayload = JSON.parse(m[1].trim());
                break;
              } catch (e) {
                core.warning('Failed to parse AI payload: ' + e.message);
              }
            }

            if (!aiPayload) {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number,
                body: 'æœªæ‰¾åˆ°å¯åº”ç”¨çš„ AI å®¡æŸ¥ç»“æœï¼Œè¯·å…ˆç­‰å¾… AI å®¡æŸ¥è¯„è®ºç”Ÿæˆåå†æ·»åŠ  `Confirm`ã€‚'
              });
              return;
            }

            const normalizeLabel = (label) => {
              const text = String(label || '').trim();
              const low = text.toLowerCase();
              const map = {
                bug: 'BUG',
                documentation: 'Documentation',
                enhancement: 'Enhancement',
                question: 'Question',
                duplicate: 'Duplicate',
                wontfix: 'WontFix',
                invalid: 'Invalid',
                'needs-info': 'Needs-Info'
              };
              return map[low] || text;
            };

            const desiredLabels = new Set((Array.isArray(aiPayload.labels) ? aiPayload.labels : []).map(normalizeLabel));

            // Remove conflicting labels first.
            const current = (issue.labels || []).map(l => (typeof l === 'string' ? l : l.name));

            const removeIfConflicts = async (group) => {
              for (const label of current) {
                if (group.includes(label) && !desiredLabels.has(label)) {
                  try {
                    await github.rest.issues.removeLabel({ owner, repo, issue_number, name: label });
                  } catch {
                    // ignore
                  }
                }
              }
            };

            await removeIfConflicts(typeGroup);
            await removeIfConflicts(negativeGroup);
            await removeIfConflicts(priorityGroup);

            // Apply desired labels from AI.
            if (desiredLabels.size > 0) {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number,
                labels: Array.from(desiredLabels)
              });
            }

            // Remove control/status labels as requested.
            for (const name of ['Confirm', 'confirm', 'NEW', 'new', 'AI-Rerun', 'ai-rerun']) {
              try {
                await github.rest.issues.removeLabel({ owner, repo, issue_number, name });
              } catch {
                // ignore absent label
              }
            }

            const hasNegative = ['Duplicate', 'WontFix', 'Invalid', 'duplicate', 'wontfix', 'invalid'].some(l => desiredLabels.has(l));

            if (hasNegative) {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number,
                body: 'å·²æ ¹æ® `Confirm` åº”ç”¨ AI å®¡æŸ¥ç»“æœï¼Œä¸”ç»“è®ºä¸ºè´Ÿå‘æ ‡ç­¾ï¼ˆ`Duplicate`/`WontFix`/`Invalid`ï¼‰ï¼Œç°è‡ªåŠ¨å…³é—­è¯¥ issueã€‚'
              });

              await github.rest.issues.update({
                owner,
                repo,
                issue_number,
                state: 'closed',
                state_reason: 'not_planned'
              });
            } else {
              const confirmer = context.payload.sender?.login;
              if (confirmer) {
                try {
                  await github.rest.issues.addAssignees({
                    owner,
                    repo,
                    issue_number,
                    assignees: [confirmer]
                  });
                } catch (e) {
                  core.warning('Failed to add assignee ' + confirmer + ': ' + e.message);
                }
              }

              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number,
                body: 'å·²æ ¹æ® `Confirm` åº”ç”¨ AI å®¡æŸ¥æ ‡ç­¾ï¼Œæµç¨‹å®Œæˆã€‚æœ¬æ¬¡ä¸ºå—ç†ç»“è®ºï¼Œå·²è‡ªåŠ¨å°†ç¡®è®¤äººåŠ å…¥ Assigneesã€‚'
              });
            }
