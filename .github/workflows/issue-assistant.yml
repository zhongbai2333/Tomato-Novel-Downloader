name: Issue Assistant

on:
  issues:
    types:
      - opened
      - edited
      - reopened
      - labeled

permissions:
  contents: read
  issues: write

jobs:
  ai-review:
    if: github.event.action == 'opened' || github.event.action == 'edited' || github.event.action == 'reopened' || (github.event.action == 'labeled' && (github.event.label.name == 'AI-Rerun' || github.event.label.name == 'ai-rerun'))
    runs-on: ubuntu-latest
    concurrency:
      group: issue-assistant-ai-review-${{ github.repository }}
      cancel-in-progress: false
    steps:
      - name: Start Copilot API proxy in local runner
        shell: bash
        env:
          COPILOT_GH_TOKEN: ${{ secrets.COPILOT_GH_TOKEN }}
        run: |
          set -euo pipefail

          if [ -z "${COPILOT_GH_TOKEN:-}" ]; then
            echo "Missing repository secret: COPILOT_GH_TOKEN"
            exit 1
          fi

          docker build -t local/copilot-api:latest https://github.com/ericc-ch/copilot-api.git#master

          docker run -d --name copilot-api \
            -p 4141:4141 \
            -e GH_TOKEN="$COPILOT_GH_TOKEN" \
            local/copilot-api:latest \
            start --port 4141 --rate-limit 10 --wait

          for i in $(seq 1 60); do
            if curl -fsS http://127.0.0.1:4141/v1/models >/dev/null 2>&1; then
              echo "copilot-api is ready"
              exit 0
            fi
            sleep 2
          done

          echo "copilot-api failed to become ready in time"
          docker logs copilot-api || true
          exit 1

      - name: Analyze issue with GPT-5-mini
        id: analyze
        uses: actions/github-script@v7
        env:
          OPENAI_BASE_URL: http://127.0.0.1:4141/v1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            let notFixPolicyDoc = '';
            try {
              const fileResp = await github.rest.repos.getContent({
                owner,
                repo,
                path: 'AI_NOT_FIX_CASES.md'
              });

              if (!Array.isArray(fileResp.data) && fileResp.data.content) {
                notFixPolicyDoc = Buffer.from(fileResp.data.content, 'base64').toString('utf8');
              }
            } catch (e) {
              core.warning('Failed to load AI_NOT_FIX_CASES.md: ' + e.message);
            }

            const openIssuesRaw = await github.paginate(github.rest.issues.listForRepo, {
              owner,
              repo,
              state: 'open',
              per_page: 100
            });

            const openIssues = openIssuesRaw
              .filter(i => !i.pull_request && i.number !== issue.number)
              .slice(0, 80)
              .map(i => {
                const labels = (i.labels || []).map(l => typeof l === 'string' ? l : l.name).filter(Boolean);
                const bodyShort = String(i.body || '').replace(/\s+/g, ' ').slice(0, 180);
                return `#${i.number} | ${i.title} | labels=[${labels.join(', ')}] | body=${bodyShort}`;
              });

            const allowedType = ['BUG', 'Documentation', 'Enhancement', 'Question'];
            const allowedNegative = ['Duplicate', 'WontFix', 'Invalid', 'duplicate', 'wontfix', 'invalid'];
            const allowedPriority = ['ğŸŸªCritical', 'ğŸŸ¥High', 'ğŸŸ¨Medium', 'ğŸŸ©Low'];

            const prompt = [
              'ä½ æ˜¯ä¸€ä¸ª GitHub Issue åˆ†è¯ŠåŠ©æ‰‹ã€‚',
              'è¯·æ ¹æ® issue æ ‡é¢˜å’Œå†…å®¹ï¼Œè¾“å‡ºä¸¥æ ¼ JSONï¼ˆä¸è¦è¾“å‡º markdown ä»£ç å—ï¼‰ã€‚',
              'è¯­è¨€è¦æ±‚ï¼šæ‰€æœ‰è‡ªç„¶è¯­è¨€å­—æ®µå¿…é¡»ä½¿ç”¨ç®€ä½“ä¸­æ–‡ï¼ˆåŒ…æ‹¬ summaryã€better_titleã€need_more_info_itemsï¼‰ã€‚',
              'ç¦æ­¢è¾“å‡ºè‹±æ–‡å¥å­ï¼ˆä¸“æœ‰åè¯ä¸æ ‡ç­¾åé™¤å¤–ï¼‰ã€‚',
              'é‡å¤åˆ¤æ–­è§„åˆ™ï¼šåªä¸â€œå½“å‰ Open Issuesâ€æ¯”è¾ƒæ˜¯å¦é‡å¤ï¼Œä¸ä½¿ç”¨ Closed Issues åšé‡å¤åˆ¤å®šã€‚',
              'ç­–ç•¥è§„åˆ™ï¼šå¯å‚è€ƒ not-fix ç­–ç•¥æ ·ä¾‹ï¼ˆAI_NOT_FIX_CASES.mdï¼‰ã€‚è‹¥å‘½ä¸­ç­–ç•¥ä¸” Open ä¸­æ— é‡å¤ï¼Œå¯ç»™ WontFixï¼›è‹¥ Open ä¸­æœ‰åŒç±»ï¼Œç»™ Duplicateã€‚',
              'å¿…é¡»åªä»ä»¥ä¸‹æšä¸¾ä¸­é€‰æ‹©æ ‡ç­¾ï¼š',
              'type: BUG | Documentation | Enhancement | Question',
              'negative: Duplicate | WontFix | Invalid | none',
              'priority: ğŸŸªCritical | ğŸŸ¥High | ğŸŸ¨Medium | ğŸŸ©Low',
              'needs_info: true | false',
              'æ ‡ç­¾é‡Šä¹‰ï¼ˆå¿…é¡»ä¸¥æ ¼æŒ‰æ­¤ç†è§£ï¼‰ï¼š',
              '- AI-Rerun: Reuse AI reviewï¼ˆäººå·¥è§¦å‘é‡æ–°å®¡æŸ¥ï¼‰',
              '- BUG: Something isn\'t working',
              '- Confirm: Agree to AI review operation',
              '- Documentation: Improvements or additions to documentation',
              '- Duplicate: This issue or pull request already exists',
              '- Enhancement: New feature or request',
              '- Invalid: There is no such issue',
              '- Needs-Info: Issue requires more information',
              '- NEW: New Issue',
              '- Question: Question related to the project',
              '- WontFix: This will not be worked on',
              '- ğŸŸ¥High: High priority',
              '- ğŸŸ¨Medium: Medium priority',
              '- ğŸŸ©Low: Low priority',
              '- ğŸŸªCritical: The program has a critical error that prevents it from running',
              'æ­¤å¤–æä¾› summary(ä¸è¶…è¿‡120å­—)ã€better_title(ç®€æ´æ˜ç¡®)ã€need_more_info_items(æ•°ç»„ï¼Œæœ€å¤š5æ¡)ã€confidence(0-1)ã€‚',
              'å¦‚æœä¿¡æ¯æ˜æ˜¾ä¸è¶³ï¼Œneeds_info å¿…é¡»ä¸º trueã€‚',
              'è‹¥ negative ä¸æ˜¯ noneï¼Œä»éœ€ç»™å‡º type ä¸ priorityã€‚',
              'æ ‡é¢˜è§„åˆ™ï¼šbetter_title å¿…é¡»æ ¹æ® type è‡ªåŠ¨åŠ å‰ç¼€ï¼šBUG=>[BUG]ï¼ŒEnhancement=>[Feature]ï¼ŒQuestion=>[Question]ï¼ŒDocumentation=>[Doc]ã€‚',
              '',
              'Issue æ ‡é¢˜ï¼š',
              issue.title,
              '',
              'Issue æ­£æ–‡ï¼š',
              body,
              '',
              'å½“å‰ Open Issuesï¼ˆç”¨äºé‡å¤åˆ¤æ–­ï¼Œä»…æ­¤åˆ—è¡¨å‚ä¸é‡å¤åˆ¤å®šï¼‰ï¼š',
              openIssues.length ? openIssues.join('\n') : 'ï¼ˆæ— ï¼‰',
              '',
              'Not-Fix ç­–ç•¥æ ·ä¾‹æ–‡æ¡£ï¼ˆç”¨äºç­–ç•¥å‚è€ƒï¼Œä¸ç›´æ¥ä½œä¸ºé‡å¤ç›®æ ‡ï¼‰ï¼š',
              notFixPolicyDoc || 'ï¼ˆæœªæ‰¾åˆ° AI_NOT_FIX_CASES.mdï¼‰'
            ].join('\n');

            const baseUrl = process.env.OPENAI_BASE_URL || 'http://127.0.0.1:4141/v1';
            const model = process.env.OPENAI_MODEL || 'gpt-5-mini';

            const headers = {
              'Content-Type': 'application/json'
            };

            if (process.env.OPENAI_API_KEY) {
              headers['Authorization'] = 'Bearer ' + process.env.OPENAI_API_KEY;
            }

            const resp = await fetch(baseUrl + '/chat/completions', {
              method: 'POST',
              headers,
              body: JSON.stringify({
                model,
                temperature: 0.1,
                response_format: { type: 'json_object' },
                messages: [
                  { role: 'system', content: 'ä½ æ˜¯ä¸¥è°¨çš„ issue å®¡æŸ¥åŠ©æ‰‹ï¼Œåªè¾“å‡º JSONï¼Œä¸”æ‰€æœ‰è‡ªç„¶è¯­è¨€å­—æ®µå¿…é¡»ä¸ºç®€ä½“ä¸­æ–‡ã€‚' },
                  { role: 'user', content: prompt }
                ]
              })
            });

            if (!resp.ok) {
              const txt = await resp.text();
              core.setFailed('OpenAI request failed: ' + resp.status + ' ' + txt);
              return;
            }

            const data = await resp.json();
            const raw = data?.choices?.[0]?.message?.content || '{}';

            let parsed;
            try {
              parsed = JSON.parse(raw);
            } catch {
              const cleaned = raw.replace(/^```json\s*/i, '').replace(/```$/i, '').trim();
              parsed = JSON.parse(cleaned);
            }

            const result = {
              summary: String(parsed.summary || '').slice(0, 300),
              better_title: String(parsed.better_title || issue.title).slice(0, 200),
              type: allowedType.includes(parsed.type) ? parsed.type : 'Question',
              negative: (parsed.negative === 'none' || !parsed.negative)
                ? 'none'
                : (allowedNegative.includes(parsed.negative)
                  ? ({
                      duplicate: 'Duplicate',
                      wontfix: 'WontFix',
                      invalid: 'Invalid'
                    }[String(parsed.negative).toLowerCase()] || parsed.negative)
                  : 'none'),
              priority: allowedPriority.includes(parsed.priority) ? parsed.priority : 'ğŸŸ¨Medium',
              needs_info: Boolean(parsed.needs_info),
              need_more_info_items: Array.isArray(parsed.need_more_info_items)
                ? parsed.need_more_info_items.slice(0, 5).map(v => String(v).slice(0, 200))
                : [],
              confidence: Math.max(0, Math.min(1, Number(parsed.confidence ?? 0.6)))
            };

            const titlePrefixByType = {
              BUG: '[BUG]',
              Enhancement: '[Feature]',
              Question: '[Question]',
              Documentation: '[Doc]'
            };
            const normalizedTitleCore = String(result.better_title || issue.title || '')
              .replace(/^\s*\[[^\]]+\]\s*/g, '')
              .trim();
            const safeTitleCore = normalizedTitleCore || 'æœªæä¾›æ ‡é¢˜';
            const prefix = titlePrefixByType[result.type] || '[Question]';
            result.better_title = `${prefix} ${safeTitleCore}`.slice(0, 200);

            const labels = [result.type, result.priority];
            if (result.negative !== 'none') labels.push(result.negative);
            if (result.needs_info) labels.push('Needs-Info');

            result.labels = labels;

            core.setOutput('result', JSON.stringify(result));

      - name: Stop Copilot API proxy
        if: always()
        shell: bash
        run: |
          set +e
          docker logs copilot-api > /tmp/copilot-api.log 2>&1 || true
          docker stop copilot-api >/dev/null 2>&1 || true
          docker rm copilot-api >/dev/null 2>&1 || true
          echo "copilot-api container cleaned"

      - name: Publish AI review comment
        if: success()
        uses: actions/github-script@v7
        env:
          AI_RESULT: ${{ steps.analyze.outputs.result }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;
            const result = JSON.parse(process.env.AI_RESULT || '{}');

            const marker = '<!-- ai-issue-review:' + JSON.stringify(result).replace(/-->/g, '--ï¼') + ' -->';
            const lines = [];
            lines.push('## ğŸ¤– AI å®¡æŸ¥ç»“æœ');
            lines.push('');
            lines.push('- **æ€»ç»“**: ' + (result.summary || 'ï¼ˆæ— ï¼‰'));
            lines.push('- **å»ºè®®æ ‡é¢˜**: ' + (result.better_title || issue.title));
            lines.push('- **å»ºè®®æ ‡ç­¾**: ' + (Array.isArray(result.labels) && result.labels.length ? result.labels.map(v => '`' + v + '`').join(' ') : 'ï¼ˆæ— ï¼‰'));
            lines.push('- **æ˜¯å¦éœ€è¦è¡¥å……ä¿¡æ¯**: ' + (result.needs_info ? 'æ˜¯' : 'å¦'));
            lines.push('- **ç½®ä¿¡åº¦**: ' + Math.round((Number(result.confidence || 0) * 100)) + '%');

            if (Array.isArray(result.need_more_info_items) && result.need_more_info_items.length > 0) {
              lines.push('');
              lines.push('### éœ€è¦è¡¥å……');
              for (const item of result.need_more_info_items) {
                lines.push('- ' + item);
              }
            }

            lines.push('');
            lines.push('ç»´æŠ¤è€…å¦‚åŒæ„æœ¬æ¬¡ AI ç»“æœï¼Œè¯·æ·»åŠ æ ‡ç­¾ `Confirm`ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨æ‰§è¡Œæ ‡ç­¾è½åœ°å¹¶ç§»é™¤ `Confirm`ã€‚');
            lines.push('å¦‚éœ€å†æ¬¡è§¦å‘ AI é‡å®¡ï¼Œå¯æ·»åŠ æ ‡ç­¾ `AI-Rerun`ã€‚');
            lines.push(marker);

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: lines.join('\n')
            });

      - name: Fallback comment when AI review fails
        if: failure()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: [
                '## âš ï¸ AI å®¡æŸ¥æš‚æ—¶å¤±è´¥',
                '',
                'æœ¬æ¬¡è‡ªåŠ¨å®¡æŸ¥æœªæˆåŠŸå®Œæˆï¼ˆå¯èƒ½æ˜¯æœåŠ¡å¯åŠ¨å¤±è´¥ã€ç½‘ç»œæ³¢åŠ¨ã€é™æµæˆ–ä¸Šæ¸¸å“åº”å¼‚å¸¸ï¼‰ã€‚',
                'ä½ å¯ä»¥ç¨åç¼–è¾‘è¯¥ Issue æˆ–é‡æ–°æ‰“å¼€ Issue ä»¥è§¦å‘å†æ¬¡å®¡æŸ¥ã€‚',
                '',
                'ç»´æŠ¤è€…ä¹Ÿå¯ç›´æ¥æ‰‹åŠ¨æ‰“æ ‡ç­¾å¤„ç†ï¼Œä¸å½±å“æ­£å¸¸æµç¨‹ã€‚'
              ].join('\\n')
            });

      - name: Remove ai-rerun label after processing
        if: always() && github.event.action == 'labeled' && (github.event.label.name == 'AI-Rerun' || github.event.label.name == 'ai-rerun')
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            for (const name of ['AI-Rerun', 'ai-rerun']) {
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.issue.number,
                  name
                });
              } catch {
                // ignore absent label
              }
            }

  confirm-apply:
    if: github.event.action == 'labeled' && (github.event.label.name == 'Confirm' || github.event.label.name == 'confirm')
    runs-on: ubuntu-latest
    steps:
      - name: Apply AI review result after confirm
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = issue.number;

            const typeGroup = ['BUG', 'Documentation', 'Enhancement', 'Question', 'bug', 'documentation', 'enhancement', 'question'];
            const negativeGroup = ['Duplicate', 'WontFix', 'Invalid', 'duplicate', 'wontfix', 'invalid'];
            const priorityGroup = ['ğŸŸªCritical', 'ğŸŸ¥High', 'ğŸŸ¨Medium', 'ğŸŸ©Low'];

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number,
              per_page: 100
            });

            const markerRegex = /<!--\s*ai-issue-review:(.*?)-->/s;
            let aiPayload = null;

            for (let i = comments.length - 1; i >= 0; i--) {
              const c = comments[i];
              if (!c.body) continue;
              const m = c.body.match(markerRegex);
              if (!m) continue;
              try {
                aiPayload = JSON.parse(m[1].trim());
                break;
              } catch (e) {
                core.warning('Failed to parse AI payload: ' + e.message);
              }
            }

            if (!aiPayload) {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number,
                body: 'æœªæ‰¾åˆ°å¯åº”ç”¨çš„ AI å®¡æŸ¥ç»“æœï¼Œè¯·å…ˆç­‰å¾… AI å®¡æŸ¥è¯„è®ºç”Ÿæˆåå†æ·»åŠ  `Confirm`ã€‚'
              });
              return;
            }

            const normalizeLabel = (label) => {
              const text = String(label || '').trim();
              const low = text.toLowerCase();
              const map = {
                bug: 'BUG',
                documentation: 'Documentation',
                enhancement: 'Enhancement',
                question: 'Question',
                duplicate: 'Duplicate',
                wontfix: 'WontFix',
                invalid: 'Invalid',
                'needs-info': 'Needs-Info'
              };
              return map[low] || text;
            };

            const desiredLabels = new Set((Array.isArray(aiPayload.labels) ? aiPayload.labels : []).map(normalizeLabel));

            // Remove conflicting labels first.
            const current = (issue.labels || []).map(l => (typeof l === 'string' ? l : l.name));

            const removeIfConflicts = async (group) => {
              for (const label of current) {
                if (group.includes(label) && !desiredLabels.has(label)) {
                  try {
                    await github.rest.issues.removeLabel({ owner, repo, issue_number, name: label });
                  } catch {
                    // ignore
                  }
                }
              }
            };

            await removeIfConflicts(typeGroup);
            await removeIfConflicts(negativeGroup);
            await removeIfConflicts(priorityGroup);

            // Apply desired labels from AI.
            if (desiredLabels.size > 0) {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number,
                labels: Array.from(desiredLabels)
              });
            }

            // Remove control/status labels as requested.
            for (const name of ['Confirm', 'confirm', 'NEW', 'new', 'AI-Rerun', 'ai-rerun']) {
              try {
                await github.rest.issues.removeLabel({ owner, repo, issue_number, name });
              } catch {
                // ignore absent label
              }
            }

            const hasNegative = ['Duplicate', 'WontFix', 'Invalid', 'duplicate', 'wontfix', 'invalid'].some(l => desiredLabels.has(l));

            if (hasNegative) {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number,
                body: 'å·²æ ¹æ® `Confirm` åº”ç”¨ AI å®¡æŸ¥ç»“æœï¼Œä¸”ç»“è®ºä¸ºè´Ÿå‘æ ‡ç­¾ï¼ˆ`Duplicate`/`WontFix`/`Invalid`ï¼‰ï¼Œç°è‡ªåŠ¨å…³é—­è¯¥ issueã€‚'
              });

              await github.rest.issues.update({
                owner,
                repo,
                issue_number,
                state: 'closed',
                state_reason: 'not_planned'
              });
            } else {
              const confirmer = context.payload.sender?.login;
              if (confirmer) {
                try {
                  await github.rest.issues.addAssignees({
                    owner,
                    repo,
                    issue_number,
                    assignees: [confirmer]
                  });
                } catch (e) {
                  core.warning('Failed to add assignee ' + confirmer + ': ' + e.message);
                }
              }

              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number,
                body: 'å·²æ ¹æ® `Confirm` åº”ç”¨ AI å®¡æŸ¥æ ‡ç­¾ï¼Œæµç¨‹å®Œæˆã€‚æœ¬æ¬¡ä¸ºå—ç†ç»“è®ºï¼Œå·²è‡ªåŠ¨å°†ç¡®è®¤äººåŠ å…¥ Assigneesã€‚'
              });
            }
